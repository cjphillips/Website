/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.31 from the
 * contents of Cudd.xs. Do not edit this file, edit Cudd.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Cudd.xs"
#ifdef __cplusplus
extern "C" {
#endif
#include "util.h"
#include "cudd/cudd.h"
#undef EXTERN
#undef ARGS
#undef assert
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifdef __cplusplus
}
#endif

static int
not_here(s)
char *s;
{
    croak("%s not implemented on this architecture", s);
    return -1;
}

static double
constant(name, arg)
char *name;
int arg;
{
    errno = 0;
    switch (*name) {
    case 'A':
	if (strEQ(name, "APA_BASE"))
#ifdef DD_APA_BASE
	    return DD_APA_BASE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "APA_BITS"))
#ifdef DD_APA_BITS
	    return DD_APA_BITS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "APA_MASK"))
#ifdef DD_APA_MASK
	    return DD_APA_MASK;
#else
	    goto not_there;
#endif
	break;
    case 'C':
	if (strEQ(name, "CACHE_SLOTS"))
#ifdef CUDD_CACHE_SLOTS
	    return CUDD_CACHE_SLOTS;
#else
	    goto not_there;
#endif
	break;
    case 'M':
	if (strEQ(name, "MAXINDEX"))
#ifdef CUDD_MAXINDEX
	    return CUDD_MAXINDEX;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MTR_DEFAULT"))
#ifdef MTR_DEFAULT
	    return MTR_DEFAULT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "MTR_FIXED"))
#ifdef MTR_FIXED
	    return MTR_FIXED;
#else
	    goto not_there;
#endif
	break;
    case 'O':
	if (strEQ(name, "OUT_OF_MEM"))
#ifdef CUDD_OUT_OF_MEM
	    return CUDD_OUT_OF_MEM;
#else
	    goto not_there;
#endif
	break;
    case 'R':
	if (strEQ(name, "REORDER_SAME"))
	    return CUDD_REORDER_SAME;
	if (strEQ(name, "REORDER_NONE"))
	    return CUDD_REORDER_NONE;
	if (strEQ(name, "REORDER_RANDOM"))
	    return CUDD_REORDER_RANDOM;
	if (strEQ(name, "REORDER_RANDOM_PIVOT"))
	    return CUDD_REORDER_RANDOM_PIVOT;
	if (strEQ(name, "REORDER_SIFT"))
	    return CUDD_REORDER_SIFT;
	if (strEQ(name, "REORDER_SIFT_CONVERGE"))
	    return CUDD_REORDER_SIFT_CONVERGE;
	if (strEQ(name, "REORDER_SYMM_SIFT"))
	    return CUDD_REORDER_SYMM_SIFT;
	if (strEQ(name, "REORDER_SYMM_SIFT_CONV"))
	    return CUDD_REORDER_SYMM_SIFT_CONV;
	if (strEQ(name, "REORDER_WINDOW2"))
	    return CUDD_REORDER_WINDOW2;
	if (strEQ(name, "REORDER_WINDOW3"))
	    return CUDD_REORDER_WINDOW3;
	if (strEQ(name, "REORDER_WINDOW4"))
	    return CUDD_REORDER_WINDOW4;
	if (strEQ(name, "REORDER_WINDOW2_CONV"))
	    return CUDD_REORDER_WINDOW2_CONV;
	if (strEQ(name, "REORDER_WINDOW3_CONV"))
	    return CUDD_REORDER_WINDOW3_CONV;
	if (strEQ(name, "REORDER_WINDOW4_CONV"))
	    return CUDD_REORDER_WINDOW4_CONV;
	if (strEQ(name, "REORDER_GROUP_SIFT"))
	    return CUDD_REORDER_GROUP_SIFT;
	if (strEQ(name, "REORDER_GROUP_SIFT_CONV"))
	    return CUDD_REORDER_GROUP_SIFT_CONV;
	if (strEQ(name, "REORDER_ANNEALING"))
	    return CUDD_REORDER_ANNEALING;
	if (strEQ(name, "REORDER_GENETIC"))
	    return CUDD_REORDER_GENETIC;
	if (strEQ(name, "REORDER_LINEAR"))
	    return CUDD_REORDER_LINEAR;
	if (strEQ(name, "REORDER_LINEAR_CONVERGE"))
	    return CUDD_REORDER_LINEAR_CONVERGE;
	if (strEQ(name, "REORDER_EXACT"))
	    return CUDD_REORDER_EXACT;
	if (strEQ(name, "RESIDUE_DEFAULT"))
#ifdef CUDD_RESIDUE_DEFAULT
	    return CUDD_RESIDUE_DEFAULT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "RESIDUE_MSB"))
#ifdef CUDD_RESIDUE_MSB
	    return CUDD_RESIDUE_MSB;
#else
	    goto not_there;
#endif
	if (strEQ(name, "RESIDUE_TC"))
#ifdef CUDD_RESIDUE_TC
	    return CUDD_RESIDUE_TC;
#else
	    goto not_there;
#endif
	break;
    case 'S':
	if (strEQ(name, "SIZEOF_INT"))
#ifdef SIZEOF_INT
	    return SIZEOF_INT;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SIZEOF_LONG"))
#ifdef SIZEOF_LONG
	    return SIZEOF_LONG;
#else
	    goto not_there;
#endif
	if (strEQ(name, "SIZEOF_VOID_P"))
#ifdef SIZEOF_VOID_P
	    return SIZEOF_VOID_P;
#else
	    goto not_there;
#endif
	break;
    case 'U':
	if (strEQ(name, "UNIQUE_SLOTS"))
#ifdef CUDD_UNIQUE_SLOTS
	    return CUDD_UNIQUE_SLOTS;
#else
	    goto not_there;
#endif
	break;
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}


#line 197 "Cudd.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 341 "Cudd.c"

XS_EUPXS(XS_Cudd_constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_constant)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "name, arg");
    {
	char *	name = (char *)SvPV_nolen(ST(0))
;
	int	arg = (int)SvIV(ST(1))
;
	double	RETVAL;
	dXSTARG;

	RETVAL = constant(name, arg);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_Init); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_Init)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 5)
       croak_xs_usage(cv,  "numVars = 0, numVarsZ = 0, numSlots = 251, cacheSize = 131071, maxMemory = 0");
    {
	unsigned int	numVars;
	unsigned int	numVarsZ;
	unsigned int	numSlots;
	unsigned int	cacheSize;
	unsigned int	maxMemory;
	DdManager *	RETVAL;

	if (items < 1)
	    numVars = 0;
	else {
	    numVars = (unsigned int)SvUV(ST(0))
;
	}

	if (items < 2)
	    numVarsZ = 0;
	else {
	    numVarsZ = (unsigned int)SvUV(ST(1))
;
	}

	if (items < 3)
	    numSlots = 251;
	else {
	    numSlots = (unsigned int)SvUV(ST(2))
;
	}

	if (items < 4)
	    cacheSize = 131071;
	else {
	    cacheSize = (unsigned int)SvUV(ST(3))
;
	}

	if (items < 5)
	    maxMemory = 0;
	else {
	    maxMemory = (unsigned int)SvUV(ST(4))
;
	}

	RETVAL = Cudd_Init(numVars, numVarsZ, numSlots, cacheSize, maxMemory);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdManagerPtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_Quit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_Quit)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "unique");
    {
	DdManager*	unique;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    unique = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::Quit",
			"unique", "DdManagerPtr")
;

	Cudd_Quit(unique);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Cudd_Ref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_Ref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "n");
    {
	DdNode*	n;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    n = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::Ref",
			"n", "DdNodePtr")
;

	Cudd_Ref(n);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Cudd_RecursiveDeref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_RecursiveDeref)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "table, n");
    {
	DdManager*	table;
	DdNode*	n;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    table = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::RecursiveDeref",
			"table", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    n = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::RecursiveDeref",
			"n", "DdNodePtr")
;

	Cudd_RecursiveDeref(table, n);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Cudd_IterDerefBdd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_IterDerefBdd)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "table, n");
    {
	DdManager*	table;
	DdNode*	n;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    table = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::IterDerefBdd",
			"table", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    n = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::IterDerefBdd",
			"n", "DdNodePtr")
;

	Cudd_IterDerefBdd(table, n);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Cudd_DelayedDerefBdd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_DelayedDerefBdd)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "table, n");
    {
	DdManager*	table;
	DdNode*	n;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    table = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::DelayedDerefBdd",
			"table", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    n = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::DelayedDerefBdd",
			"n", "DdNodePtr")
;

	Cudd_DelayedDerefBdd(table, n);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Cudd_ReadOne); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_ReadOne)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dd");
    {
	DdManager*	dd;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::ReadOne",
			"dd", "DdManagerPtr")
;

	RETVAL = Cudd_ReadOne(dd);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_DagSize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_DagSize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "node");
    {
	DdNode*	node;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    node = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::DagSize",
			"node", "DdNodePtr")
;

	RETVAL = Cudd_DagSize(node);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_CountMinterm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_CountMinterm)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "manager, node, nvars");
    {
	DdManager*	manager;
	DdNode*	node;
	int	nvars = (int)SvIV(ST(2))
;
	double	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    manager = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::CountMinterm",
			"manager", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    node = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::CountMinterm",
			"node", "DdNodePtr")
;

	RETVAL = Cudd_CountMinterm(manager, node, nvars);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_PrintDebug); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_PrintDebug)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dd, f, n, pr");
    {
	DdManager*	dd;
	DdNode*	f;
	int	n = (int)SvIV(ST(2))
;
	int	pr = (int)SvIV(ST(3))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::PrintDebug",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::PrintDebug",
			"f", "DdNodePtr")
;

	RETVAL = Cudd_PrintDebug(dd, f, n, pr);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_PrintInfo); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_PrintInfo)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dd");
    {
	DdManager*	dd;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::PrintInfo",
			"dd", "DdManagerPtr")
;
#line 252 "Cudd.xs"
	RETVAL = Cudd_PrintInfo(dd,stdout);
#line 749 "Cudd.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_ReadPeakLiveNodeCount); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_ReadPeakLiveNodeCount)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dd");
    {
	DdManager*	dd;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::ReadPeakLiveNodeCount",
			"dd", "DdManagerPtr")
;

	RETVAL = Cudd_ReadPeakLiveNodeCount(dd);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_ReadNodeCount); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_ReadNodeCount)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dd");
    {
	DdManager*	dd;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::ReadNodeCount",
			"dd", "DdManagerPtr")
;

	RETVAL = Cudd_ReadNodeCount(dd);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddNewVar); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddNewVar)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dd");
    {
	DdManager*	dd;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddNewVar",
			"dd", "DdManagerPtr")
;

	RETVAL = Cudd_bddNewVar(dd);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddNewVarAtLevel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddNewVarAtLevel)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dd, level");
    {
	DdManager*	dd;
	int	level = (int)SvIV(ST(1))
;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddNewVarAtLevel",
			"dd", "DdManagerPtr")
;

	RETVAL = Cudd_bddNewVarAtLevel(dd, level);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_MakeTreeNode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_MakeTreeNode)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "dd, low, size, type = MTR_DEFAULT");
    {
	DdManager*	dd;
	unsigned int	low = (unsigned int)SvUV(ST(1))
;
	unsigned int	size = (unsigned int)SvUV(ST(2))
;
	unsigned int	type;
#line 280 "Cudd.xs"
	MtrNode *node;
#line 893 "Cudd.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::MakeTreeNode",
			"dd", "DdManagerPtr")
;

	if (items < 4)
	    type = MTR_DEFAULT;
	else {
	    type = (unsigned int)SvUV(ST(3))
;
	}
#line 282 "Cudd.xs"
	node = Cudd_MakeTreeNode(dd, low, size, type);
	RETVAL = node != NULL;
#line 916 "Cudd.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddAnd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddAnd)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dd, f, g");
    {
	DdManager*	dd;
	DdNode*	f;
	DdNode*	g;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddAnd",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddAnd",
			"f", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    g = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddAnd",
			"g", "DdNodePtr")
;

	RETVAL = Cudd_bddAnd(dd, f, g);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddOr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddOr)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dd, f, g");
    {
	DdManager*	dd;
	DdNode*	f;
	DdNode*	g;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddOr",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddOr",
			"f", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    g = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddOr",
			"g", "DdNodePtr")
;

	RETVAL = Cudd_bddOr(dd, f, g);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddXor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddXor)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dd, f, g");
    {
	DdManager*	dd;
	DdNode*	f;
	DdNode*	g;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddXor",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddXor",
			"f", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    g = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddXor",
			"g", "DdNodePtr")
;

	RETVAL = Cudd_bddXor(dd, f, g);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddXnor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddXnor)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dd, f, g");
    {
	DdManager*	dd;
	DdNode*	f;
	DdNode*	g;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddXnor",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddXnor",
			"f", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    g = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddXnor",
			"g", "DdNodePtr")
;

	RETVAL = Cudd_bddXnor(dd, f, g);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddNand); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddNand)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dd, f, g");
    {
	DdManager*	dd;
	DdNode*	f;
	DdNode*	g;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddNand",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddNand",
			"f", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    g = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddNand",
			"g", "DdNodePtr")
;

	RETVAL = Cudd_bddNand(dd, f, g);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddNor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddNor)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dd, f, g");
    {
	DdManager*	dd;
	DdNode*	f;
	DdNode*	g;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddNor",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddNor",
			"f", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    g = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddNor",
			"g", "DdNodePtr")
;

	RETVAL = Cudd_bddNor(dd, f, g);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddConstrain); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddConstrain)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dd, f, c");
    {
	DdManager*	dd;
	DdNode*	f;
	DdNode*	c;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddConstrain",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddConstrain",
			"f", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    c = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddConstrain",
			"c", "DdNodePtr")
;

	RETVAL = Cudd_bddConstrain(dd, f, c);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddRestrict); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddRestrict)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dd, f, c");
    {
	DdManager*	dd;
	DdNode*	f;
	DdNode*	c;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddRestrict",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddRestrict",
			"f", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    c = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddRestrict",
			"c", "DdNodePtr")
;

	RETVAL = Cudd_bddRestrict(dd, f, c);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddSqueeze); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddSqueeze)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dd, l, u");
    {
	DdManager*	dd;
	DdNode*	l;
	DdNode*	u;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddSqueeze",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    l = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddSqueeze",
			"l", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    u = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddSqueeze",
			"u", "DdNodePtr")
;

	RETVAL = Cudd_bddSqueeze(dd, l, u);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddExistAbstract); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddExistAbstract)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "manager, f, cube");
    {
	DdManager*	manager;
	DdNode*	f;
	DdNode*	cube;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    manager = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddExistAbstract",
			"manager", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddExistAbstract",
			"f", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    cube = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddExistAbstract",
			"cube", "DdNodePtr")
;

	RETVAL = Cudd_bddExistAbstract(manager, f, cube);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddAndAbstract); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddAndAbstract)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "manager, f, g, cube");
    {
	DdManager*	manager;
	DdNode*	f;
	DdNode*	g;
	DdNode*	cube;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    manager = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddAndAbstract",
			"manager", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddAndAbstract",
			"f", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    g = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddAndAbstract",
			"g", "DdNodePtr")
;

	if (SvROK(ST(3)) && sv_derived_from(ST(3), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(3)));
	    cube = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddAndAbstract",
			"cube", "DdNodePtr")
;

	RETVAL = Cudd_bddAndAbstract(manager, f, g, cube);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddUnivAbstract); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddUnivAbstract)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "manager, f, cube");
    {
	DdManager*	manager;
	DdNode*	f;
	DdNode*	cube;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    manager = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddUnivAbstract",
			"manager", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddUnivAbstract",
			"f", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    cube = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddUnivAbstract",
			"cube", "DdNodePtr")
;

	RETVAL = Cudd_bddUnivAbstract(manager, f, cube);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddCompose); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddCompose)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dd, f, g, v");
    {
	DdManager*	dd;
	DdNode*	f;
	DdNode*	g;
	int	v = (int)SvIV(ST(3))
;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddCompose",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddCompose",
			"f", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    g = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddCompose",
			"g", "DdNodePtr")
;

	RETVAL = Cudd_bddCompose(dd, f, g, v);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddBooleanDiff); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddBooleanDiff)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "manager, f, x");
    {
	DdManager*	manager;
	DdNode*	f;
	int	x = (int)SvIV(ST(2))
;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    manager = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddBooleanDiff",
			"manager", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddBooleanDiff",
			"f", "DdNodePtr")
;

	RETVAL = Cudd_bddBooleanDiff(manager, f, x);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddCorrelation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddCorrelation)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "manager, f, g");
    {
	DdManager*	manager;
	DdNode*	f;
	DdNode*	g;
	double	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    manager = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddCorrelation",
			"manager", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddCorrelation",
			"f", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    g = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddCorrelation",
			"g", "DdNodePtr")
;

	RETVAL = Cudd_bddCorrelation(manager, f, g);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_Decreasing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_Decreasing)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dd, f, i");
    {
	DdManager*	dd;
	DdNode*	f;
	int	i = (int)SvIV(ST(2))
;
#line 385 "Cudd.xs"
	DdNode *node;
#line 1746 "Cudd.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::Decreasing",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::Decreasing",
			"f", "DdNodePtr")
;
#line 387 "Cudd.xs"
	node = Cudd_Decreasing(dd, f, i);
	RETVAL = node == Cudd_ReadOne(dd);
#line 1772 "Cudd.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_Increasing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_Increasing)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dd, f, i");
    {
	DdManager*	dd;
	DdNode*	f;
	int	i = (int)SvIV(ST(2))
;
#line 398 "Cudd.xs"
	DdNode *node;
#line 1792 "Cudd.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::Increasing",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::Increasing",
			"f", "DdNodePtr")
;
#line 400 "Cudd.xs"
	node = Cudd_Increasing(dd, f, i);
	RETVAL = node == Cudd_ReadOne(dd);
#line 1818 "Cudd.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_FindEssential); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_FindEssential)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dd, f");
    {
	DdManager*	dd;
	DdNode*	f;
#line 410 "Cudd.xs"
	DdNode *zero, *essent, *cube, *scan;
	int complement;
	SV *sv;
#line 1838 "Cudd.c"
	AV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::FindEssential",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::FindEssential",
			"f", "DdNodePtr")
;
#line 414 "Cudd.xs"
	cube = Cudd_FindEssential(dd, f);
	Cudd_Ref(cube);
	RETVAL = newAV();
	complement = Cudd_IsComplement(cube);
	scan = Cudd_Regular(cube);

	while (!Cudd_IsConstant(scan)) {
		zero = complement ? Cudd_ReadOne(dd) : Cudd_ReadLogicZero(dd);
		essent = Cudd_bddIthVar(dd, Cudd_NodeReadIndex(scan));
		if (Cudd_T(scan) == zero) {
			essent = Cudd_Not(essent);
			complement ^= Cudd_IsComplement(Cudd_E(scan));
			scan = Cudd_Regular(Cudd_E(scan));
		} else {
			scan = Cudd_T(scan);
		}
		sv = newSViv((IV)0);
		sv_setref_pv(sv, "DdNodePtr", (void*)essent);
		av_push(RETVAL, sv);
	}
	Cudd_RecursiveDeref(dd,cube);
#line 1882 "Cudd.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
#line 439 "Cudd.xs"
	SvREFCNT_dec(RETVAL);
#line 1891 "Cudd.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_Support); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_Support)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dd, f");
    {
	DdManager*	dd;
	DdNode*	f;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::Support",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::Support",
			"f", "DdNodePtr")
;

	RETVAL = Cudd_Support(dd, f);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddLiteralSetIntersection); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddLiteralSetIntersection)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dd, f, g");
    {
	DdManager*	dd;
	DdNode*	f;
	DdNode*	g;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddLiteralSetIntersection",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddLiteralSetIntersection",
			"f", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    g = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddLiteralSetIntersection",
			"g", "DdNodePtr")
;

	RETVAL = Cudd_bddLiteralSetIntersection(dd, f, g);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddSwapVariables); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddSwapVariables)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dd, f, x, y");
    {
	DdManager*	dd;
	DdNode*	f;
#line 457 "Cudd.xs"
	I32 len;
	I32 index;
	SV  *rvx, *rvy;
	SV  *svx, *svy;
	DdNode  **xvars, **yvars;
#line 2009 "Cudd.c"
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddSwapVariables",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddSwapVariables",
			"f", "DdNodePtr")
;
#line 463 "Cudd.xs"
	rvx = ST(2);
	rvy = ST(3);
	if (!SvROK(rvx) || !SvROK(rvy))
		croak("Not a reference given to SwapVariables");
	svx = SvRV(rvx);
	svy = SvRV(rvy);
	if (SvTYPE(svx) != SVt_PVAV || SvTYPE(svy) != SVt_PVAV)
		croak("Not array reference given to SwapVariables");
	if (av_len((AV*)svx) < 0)
		croak("Empty array reference given to SwapVariables");
	if (av_len((AV*)svx) != av_len((AV*)svy))
		croak("SwapVariables given variable sets of different size");
	len = av_len((AV*)svx) + 1;
	xvars = (DdNode **) safemalloc(len * sizeof(DdNode *));
	yvars = (DdNode **) safemalloc(len * sizeof(DdNode *));
	for (index = 0; index < len; index++) {
		xvars[index] = (DdNode *)
			SvIV(SvRV(*av_fetch((AV*)svx, index, FALSE)));
		yvars[index] = (DdNode *)
			SvIV(SvRV(*av_fetch((AV*)svy, index, FALSE)));
	}
	RETVAL = Cudd_bddSwapVariables(dd, f, xvars, yvars, len);
	safefree(xvars);
	safefree(yvars);
#line 2056 "Cudd.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_SubsetHeavyBranch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_SubsetHeavyBranch)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dd, f, numVars, threshold");
    {
	DdManager*	dd;
	DdNode*	f;
	int	numVars = (int)SvIV(ST(2))
;
	int	threshold = (int)SvIV(ST(3))
;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::SubsetHeavyBranch",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::SubsetHeavyBranch",
			"f", "DdNodePtr")
;

	RETVAL = Cudd_SubsetHeavyBranch(dd, f, numVars, threshold);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_SupersetHeavyBranch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_SupersetHeavyBranch)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dd, f, numVars, threshold");
    {
	DdManager*	dd;
	DdNode*	f;
	int	numVars = (int)SvIV(ST(2))
;
	int	threshold = (int)SvIV(ST(3))
;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::SupersetHeavyBranch",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::SupersetHeavyBranch",
			"f", "DdNodePtr")
;

	RETVAL = Cudd_SupersetHeavyBranch(dd, f, numVars, threshold);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_SubsetShortPaths); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_SubsetShortPaths)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "dd, f, numVars, threshold, hardlimit");
    {
	DdManager*	dd;
	DdNode*	f;
	int	numVars = (int)SvIV(ST(2))
;
	int	threshold = (int)SvIV(ST(3))
;
	int	hardlimit = (int)SvIV(ST(4))
;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::SubsetShortPaths",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::SubsetShortPaths",
			"f", "DdNodePtr")
;

	RETVAL = Cudd_SubsetShortPaths(dd, f, numVars, threshold, hardlimit);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_SupersetShortPaths); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_SupersetShortPaths)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "dd, f, numVars, threshold, hardlimit");
    {
	DdManager*	dd;
	DdNode*	f;
	int	numVars = (int)SvIV(ST(2))
;
	int	threshold = (int)SvIV(ST(3))
;
	int	hardlimit = (int)SvIV(ST(4))
;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::SupersetShortPaths",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::SupersetShortPaths",
			"f", "DdNodePtr")
;

	RETVAL = Cudd_SupersetShortPaths(dd, f, numVars, threshold, hardlimit);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_Not); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_Not)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "f");
    {
	DdNode*	f;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::Not",
			"f", "DdNodePtr")
;

	RETVAL = Cudd_Not(f);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_ReadPerm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_ReadPerm)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dd, index");
    {
	DdManager*	dd;
	int	index = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::ReadPerm",
			"dd", "DdManagerPtr")
;

	RETVAL = Cudd_ReadPerm(dd, index);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddLeq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddLeq)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dd, f, g");
    {
	DdManager*	dd;
	DdNode*	f;
	DdNode*	g;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddLeq",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddLeq",
			"f", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    g = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddLeq",
			"g", "DdNodePtr")
;

	RETVAL = Cudd_bddLeq(dd, f, g);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_ShortestPath); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_ShortestPath)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "manager, f, length");
    {
	DdManager*	manager;
	DdNode*	f;
	int	length = (int)SvIV(ST(2))
;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    manager = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::ShortestPath",
			"manager", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::ShortestPath",
			"f", "DdNodePtr")
;
#line 541 "Cudd.xs"
	    RETVAL = Cudd_ShortestPath(manager, f, NULL, NULL, &length);
#line 2406 "Cudd.c"
	sv_setiv(ST(2), (IV)length);
	SvSETMAGIC(ST(2));
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_AutodynEnable); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_AutodynEnable)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "unique, method = CUDD_REORDER_SAME");
    {
	DdManager*	unique;
	int	method;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    unique = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::AutodynEnable",
			"unique", "DdManagerPtr")
;

	if (items < 2)
	    method = CUDD_REORDER_SAME;
	else {
	    method = (int)SvIV(ST(1))
;
	}

	Cudd_AutodynEnable(unique, method);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Cudd_AutodynDisable); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_AutodynDisable)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "unique");
    {
	DdManager*	unique;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    unique = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::AutodynDisable",
			"unique", "DdManagerPtr")
;

	Cudd_AutodynDisable(unique);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Cudd_EnableReorderingReporting); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_EnableReorderingReporting)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dd");
    {
	DdManager*	dd;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::EnableReorderingReporting",
			"dd", "DdManagerPtr")
;

	RETVAL = Cudd_EnableReorderingReporting(dd);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_DisableReorderingReporting); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_DisableReorderingReporting)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dd");
    {
	DdManager*	dd;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::DisableReorderingReporting",
			"dd", "DdManagerPtr")
;

	RETVAL = Cudd_DisableReorderingReporting(dd);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_ReduceHeap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_ReduceHeap)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "table, heuristic = CUDD_REORDER_SIFT, minsize = 1");
    {
	DdManager*	table;
	int	heuristic;
	int	minsize;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    table = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::ReduceHeap",
			"table", "DdManagerPtr")
;

	if (items < 2)
	    heuristic = CUDD_REORDER_SIFT;
	else {
	    heuristic = (int)SvIV(ST(1))
;
	}

	if (items < 3)
	    minsize = 1;
	else {
	    minsize = (int)SvIV(ST(2))
;
	}

	RETVAL = Cudd_ReduceHeap(table, heuristic, minsize);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_ShuffleHeap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_ShuffleHeap)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "table, permutation");
    {
	DdManager*	table;
#line 573 "Cudd.xs"
    I32 len;
    I32 index;
    SV  *rv;
    SV  *sv;
    int  *parray;
#line 2592 "Cudd.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    table = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::ShuffleHeap",
			"table", "DdManagerPtr")
;
#line 579 "Cudd.xs"
    rv = ST(1);
    if (!SvROK(rv))
	croak("Not a reference given to Shuffle");
    sv = SvRV(rv);
    if (SvTYPE(sv) != SVt_PVAV)
	croak("Not array reference given to Shuffle");
    if (av_len((AV*)sv) < 0)
	croak("Empty array reference given to Shuffle");
    len = av_len((AV*)sv) + 1;
    if (len != Cudd_ReadSize(table))
	croak("Wrong number of variables");
    parray = (int *) safemalloc(len * sizeof(int));
    for (index = 0; index < len; index++) {
	parray[index] = SvIV(*av_fetch((AV*)sv, index, FALSE));
    }
    RETVAL = Cudd_ShuffleHeap(table,parray);
    safefree(parray);
#line 2623 "Cudd.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_ReadSize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_ReadSize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dd");
    {
	DdManager*	dd;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::ReadSize",
			"dd", "DdManagerPtr")
;

	RETVAL = Cudd_ReadSize(dd);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_NodeReadIndex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_NodeReadIndex)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "node");
    {
	DdNode*	node;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    node = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::NodeReadIndex",
			"node", "DdNodePtr")
;

	RETVAL = Cudd_NodeReadIndex(node);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_IsComplement); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_IsComplement)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "node");
    {
	DdNode*	node;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    node = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::IsComplement",
			"node", "DdNodePtr")
;

	RETVAL = Cudd_IsComplement(node);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_CheckZeroRef); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_CheckZeroRef)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "manager");
    {
	DdManager*	manager;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    manager = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::CheckZeroRef",
			"manager", "DdManagerPtr")
;

	RETVAL = Cudd_CheckZeroRef(manager);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_DumpDot); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_DumpDot)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dd, f, onameref, inameref");
    {
	DdManager *	dd;
#line 620 "Cudd.xs"
	I32 leno, leni;
	I32 index;
	SV  *rvf, *rvo, *rvi;
	SV  *svf, *svo, *svi;
	DdNode  **fa;
	char **onames, **inames;
#line 2757 "Cudd.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::DumpDot",
			"dd", "DdManagerPtr")
;
#line 627 "Cudd.xs"
	/* Process list of output nodes. */
	rvf = ST(1);
	if (!SvROK(rvf))
		croak("Not a reference given to Dot");
	svf = SvRV(rvf);
	if (SvTYPE(svf) != SVt_PVAV)
		croak("Not array reference given to Dot");
	if (av_len((AV*)svf) < 0)
		croak("Empty array reference given to Dot");
	leno = av_len((AV*)svf) + 1;
	fa = (DdNode **) safemalloc(leno * sizeof(DdNode *));
	for (index = 0; index < leno; index++) {
		fa[index] = (DdNode *)
			SvIV(SvRV(*av_fetch((AV*)svf, index, FALSE)));
	}
	/* Process list of output names. */
	rvo = ST(2);
	if (!SvROK(rvo))
		croak("Not a reference given to Dot");
	svo = SvRV(rvo);
	if (SvTYPE(svo) != SVt_PVAV)
		croak("Not array reference given to Dot");
	if (av_len((AV*)svo) < 0) {
		onames = NULL;
	} else {
		if (leno != av_len((AV*)svo) + 1)
			croak("Number of output names is incorrect in Dot");
		onames = (char **) safemalloc(leno * sizeof(char *));
		for (index = 0; index < leno; index++) {
			onames[index] =
				SvPV(*av_fetch((AV*)svo, index, FALSE), PL_na);
		}
	}
	/* Process list of input names. */
	rvi = ST(3);
	if (!SvROK(rvi))
		croak("Not a reference given to Dot");
	svi = SvRV(rvi);
	if (SvTYPE(svi) != SVt_PVAV)
		croak("Not array reference given to Dot");
	if (av_len((AV*)svi) < 0) {
		inames = NULL;
	} else {
		leni = av_len((AV*)svi) + 1;
		if (leni != Cudd_ReadSize(dd))
			croak("Number of input names is incorrect in Dot");
		inames = (char **) safemalloc(leni * sizeof(char *));
		for (index = 0; index < leni; index++) {
			inames[index] =
				SvPV(*av_fetch((AV*)svi, index, FALSE), PL_na);
		}
	}
	RETVAL = Cudd_DumpDot(dd, leno, fa, inames, onames, stdout);
	safefree(fa);
	if (onames != NULL) safefree(onames);
	if (inames != NULL) safefree(inames);
#line 2827 "Cudd.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_SolveEqn); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_SolveEqn)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dd, F, Y, n");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DdManager*	dd;
	DdNode*	F;
	DdNode*	Y;
	int	n = (int)SvIV(ST(3))
;
#line 693 "Cudd.xs"
	DdNode *consist;
	I32 index;
	AV *pG;
	DdNode **G;
	int *yIndex;
	SV *sv;
#line 2855 "Cudd.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::SolveEqn",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    F = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::SolveEqn",
			"F", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    Y = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::SolveEqn",
			"Y", "DdNodePtr")
;
#line 700 "Cudd.xs"
	G = (DdNode **) safemalloc(n * sizeof(DdNode *));
	consist = Cudd_SolveEqn(dd, F, Y, G, &yIndex, n);
	pG = newAV();
	for (index = 0; index < n; index++) {
		sv = newSViv((IV)0);
		sv_setref_pv(sv, "DdNodePtr", (void*)G[index]);
		av_push(pG, sv);
	}
	safefree(G);
	FREE(yIndex);
	EXTEND(sp,2);
	sv = newSViv((IV)0);
	PUSHs(sv_2mortal(sv_setref_pv(sv, "DdNodePtr", (void*)consist)));
	PUSHs(sv_2mortal(newRV((SV*)pG)));
#line 2901 "Cudd.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Cudd_CofMinterm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_CofMinterm)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dd, node");
    {
	DdManager*	dd;
	DdNode*	node;
#line 720 "Cudd.xs"
	int n;
	I32 index;
	double *signatures;
	SV *sv;
#line 2922 "Cudd.c"
	AV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::CofMinterm",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    node = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::CofMinterm",
			"node", "DdNodePtr")
;
#line 725 "Cudd.xs"
	n = Cudd_ReadSize(dd);
	signatures = Cudd_CofMinterm(dd, node);
	RETVAL = newAV();
	for (index = 0; index <= n; index++) {
		sv = newSVnv(signatures[index]);
		av_push(RETVAL, sv);
	}
	FREE(signatures);
#line 2953 "Cudd.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
#line 737 "Cudd.xs"
	SvREFCNT_dec(RETVAL);
#line 2962 "Cudd.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_ReorderingStatus); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_ReorderingStatus)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "dd");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DdManager*	dd;
#line 743 "Cudd.xs"
	Cudd_ReorderingType method;
	int enabled;
#line 2981 "Cudd.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::ReorderingStatus",
			"dd", "DdManagerPtr")
;
#line 746 "Cudd.xs"
	enabled = Cudd_ReorderingStatus(dd, &method);
	EXTEND(sp, 2);
	PUSHs(sv_2mortal(newSViv(enabled)));
	PUSHs(sv_2mortal(newSViv(method)));
#line 2997 "Cudd.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Cudd_bddIntersect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddIntersect)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "dd, f, g");
    {
	DdManager*	dd;
	DdNode*	f;
	DdNode*	g;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddIntersect",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddIntersect",
			"f", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    g = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddIntersect",
			"g", "DdNodePtr")
;

	RETVAL = Cudd_bddIntersect(dd, f, g);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddConstrainDecomp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddConstrainDecomp)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dd, f");
    {
	DdManager*	dd;
	DdNode*	f;
#line 762 "Cudd.xs"
	DdNode **array;
	int i, nvars;
	SV *sv;
#line 3071 "Cudd.c"
	AV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddConstrainDecomp",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddConstrainDecomp",
			"f", "DdNodePtr")
;
#line 766 "Cudd.xs"
	array = Cudd_bddConstrainDecomp(dd, f);
	RETVAL = newAV();
	nvars = Cudd_ReadSize(dd);
	for (i = 0; i < nvars; i++) {
		sv = newSViv((IV)0);
		sv_setref_pv(sv, "DdNodePtr", (void*)array[i]);
		av_push(RETVAL, sv);
	}
	FREE(array);
#line 3103 "Cudd.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
#line 779 "Cudd.xs"
	SvREFCNT_dec(RETVAL);
#line 3112 "Cudd.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_bddCharToVect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_bddCharToVect)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "dd, f");
    {
	DdManager*	dd;
	DdNode*	f;
#line 786 "Cudd.xs"
	DdNode **array;
	int i, nvars;
	SV *sv;
#line 3131 "Cudd.c"
	AV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddCharToVect",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    f = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::bddCharToVect",
			"f", "DdNodePtr")
;
#line 790 "Cudd.xs"
	array = Cudd_bddCharToVect(dd, f);
	RETVAL = newAV();
	nvars = Cudd_ReadSize(dd);
	for (i = 0; i < nvars; i++) {
		sv = newSViv((IV)0);
		sv_setref_pv(sv, "DdNodePtr", (void*)array[i]);
		av_push(RETVAL, sv);
	}
	FREE(array);
#line 3163 "Cudd.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
#line 803 "Cudd.xs"
	SvREFCNT_dec(RETVAL);
#line 3172 "Cudd.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_PrioritySelect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_PrioritySelect)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "dd, R, Pi, xvarref, yvarref, zvarref");
    {
	DdManager*	dd;
	DdNode*	R;
	DdNode*	Pi;
#line 811 "Cudd.xs"
	I32 len;
	I32 index;
	SV  *rvx, *rvy, *rvz;
	SV  *svx, *svy, *svz;
	DdNode  **xvars, **yvars, **zvars;
#line 3194 "Cudd.c"
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::PrioritySelect",
			"dd", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    R = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::PrioritySelect",
			"R", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    Pi = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::PrioritySelect",
			"Pi", "DdNodePtr")
;
#line 817 "Cudd.xs"
	rvx = ST(3);
	rvy = ST(4);
	rvz = ST(5);
	if (!SvROK(rvx) || !SvROK(rvy) || !SvROK(rvz))
		croak("Not a reference given to PrioritySelect");
	svx = SvRV(rvx);
	svy = SvRV(rvy);
	svz = SvRV(rvz);
	if (SvTYPE(svx) != SVt_PVAV || SvTYPE(svy) != SVt_PVAV ||
	    SvTYPE(svz) != SVt_PVAV)
		croak("Not array reference given to PrioritySelect");
	if (av_len((AV*)svx) < 0)
		croak("Empty array reference given to PrioritySelect");
	if (av_len((AV*)svx) != av_len((AV*)svy) ||
	    av_len((AV*)svx) != av_len((AV*)svz))
		croak("PrioritySelect given variable sets of different size");
	len = av_len((AV*)svx) + 1;
	xvars = (DdNode **) safemalloc(len * sizeof(DdNode *));
	yvars = (DdNode **) safemalloc(len * sizeof(DdNode *));
	zvars = (DdNode **) safemalloc(len * sizeof(DdNode *));
	for (index = 0; index < len; index++) {
		xvars[index] = (DdNode *)
			SvIV(SvRV(*av_fetch((AV*)svx, index, FALSE)));
		yvars[index] = (DdNode *)
			SvIV(SvRV(*av_fetch((AV*)svy, index, FALSE)));
		zvars[index] = (DdNode *)
			SvIV(SvRV(*av_fetch((AV*)svz, index, FALSE)));
	}
	RETVAL = Cudd_PrioritySelect(dd, R, xvars, yvars, zvars, Pi,
				     len, NULL);
	safefree(xvars);
	safefree(yvars);
	safefree(zvars);
#line 3260 "Cudd.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_Dxygtdxz); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_Dxygtdxz)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dd, xvarref, yvarref, zvarref");
    {
	DdManager*	dd;
#line 857 "Cudd.xs"
	I32 len;
	I32 index;
	SV  *rvx, *rvy, *rvz;
	SV  *svx, *svy, *svz;
	DdNode  **xvars, **yvars, **zvars;
#line 3286 "Cudd.c"
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::Dxygtdxz",
			"dd", "DdManagerPtr")
;
#line 863 "Cudd.xs"
	rvx = ST(1);
	rvy = ST(2);
	rvz = ST(3);
	if (!SvROK(rvx) || !SvROK(rvy) || !SvROK(rvz))
		croak("Not a reference given to Dxygtdxz");
	svx = SvRV(rvx);
	svy = SvRV(rvy);
	svz = SvRV(rvz);
	if (SvTYPE(svx) != SVt_PVAV || SvTYPE(svy) != SVt_PVAV ||
	    SvTYPE(svz) != SVt_PVAV)
		croak("Not array reference given to Dxygtdxz");
	if (av_len((AV*)svx) < 0)
		croak("Empty array reference given to Dxygtdxz");
	if (av_len((AV*)svx) != av_len((AV*)svy) ||
	    av_len((AV*)svx) != av_len((AV*)svz))
		croak("Dxygtdxz given variable sets of different size");
	len = av_len((AV*)svx) + 1;
	xvars = (DdNode **) safemalloc(len * sizeof(DdNode *));
	yvars = (DdNode **) safemalloc(len * sizeof(DdNode *));
	zvars = (DdNode **) safemalloc(len * sizeof(DdNode *));
	for (index = 0; index < len; index++) {
		xvars[index] = (DdNode *)
			SvIV(SvRV(*av_fetch((AV*)svx, index, FALSE)));
		yvars[index] = (DdNode *)
			SvIV(SvRV(*av_fetch((AV*)svy, index, FALSE)));
		zvars[index] = (DdNode *)
			SvIV(SvRV(*av_fetch((AV*)svz, index, FALSE)));
	}
	RETVAL = Cudd_Dxygtdxz(dd, len, xvars, yvars, zvars);
	safefree(xvars);
	safefree(yvars);
	safefree(zvars);
#line 3331 "Cudd.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_Dxygtdyz); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_Dxygtdyz)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dd, xvarref, yvarref, zvarref");
    {
	DdManager*	dd;
#line 902 "Cudd.xs"
	I32 len;
	I32 index;
	SV  *rvx, *rvy, *rvz;
	SV  *svx, *svy, *svz;
	DdNode  **xvars, **yvars, **zvars;
#line 3357 "Cudd.c"
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::Dxygtdyz",
			"dd", "DdManagerPtr")
;
#line 908 "Cudd.xs"
	rvx = ST(1);
	rvy = ST(2);
	rvz = ST(3);
	if (!SvROK(rvx) || !SvROK(rvy) || !SvROK(rvz))
		croak("Not a reference given to Dxygtdyz");
	svx = SvRV(rvx);
	svy = SvRV(rvy);
	svz = SvRV(rvz);
	if (SvTYPE(svx) != SVt_PVAV || SvTYPE(svy) != SVt_PVAV ||
	    SvTYPE(svz) != SVt_PVAV)
		croak("Not array reference given to Dxygtdyz");
	if (av_len((AV*)svx) < 0)
		croak("Empty array reference given to Dxygtdyz");
	if (av_len((AV*)svx) != av_len((AV*)svy) ||
	    av_len((AV*)svx) != av_len((AV*)svz))
		croak("Dxygtdyz given variable sets of different size");
	len = av_len((AV*)svx) + 1;
	xvars = (DdNode **) safemalloc(len * sizeof(DdNode *));
	yvars = (DdNode **) safemalloc(len * sizeof(DdNode *));
	zvars = (DdNode **) safemalloc(len * sizeof(DdNode *));
	for (index = 0; index < len; index++) {
		xvars[index] = (DdNode *)
			SvIV(SvRV(*av_fetch((AV*)svx, index, FALSE)));
		yvars[index] = (DdNode *)
			SvIV(SvRV(*av_fetch((AV*)svy, index, FALSE)));
		zvars[index] = (DdNode *)
			SvIV(SvRV(*av_fetch((AV*)svz, index, FALSE)));
	}
	RETVAL = Cudd_Dxygtdyz(dd, len, xvars, yvars, zvars);
	safefree(xvars);
	safefree(yvars);
	safefree(zvars);
#line 3402 "Cudd.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_Xgty); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_Xgty)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dd, zvarref, xvarref, yvarref");
    {
	DdManager*	dd;
#line 947 "Cudd.xs"
	I32 len;
	I32 index;
	SV  *rvx, *rvy, *rvz;
	SV  *svx, *svy, *svz;
	DdNode  **xvars, **yvars, **zvars;
#line 3428 "Cudd.c"
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dd = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::Xgty",
			"dd", "DdManagerPtr")
;
#line 953 "Cudd.xs"
	rvz = ST(1);
	rvx = ST(2);
	rvy = ST(3);
	if (!SvROK(rvx) || !SvROK(rvy) || !SvROK(rvz))
		croak("Not a reference given to Xgty");
	svz = SvRV(rvz);
	svx = SvRV(rvx);
	svy = SvRV(rvy);
	if (SvTYPE(svx) != SVt_PVAV || SvTYPE(svy) != SVt_PVAV ||
	    SvTYPE(svz) != SVt_PVAV)
		croak("Not array reference given to Xgty");
	if (av_len((AV*)svx) < 0)
		croak("Empty array reference given to Xgty");
	if (av_len((AV*)svx) != av_len((AV*)svy))
		croak("Xgty given variable sets of different size");
	len = av_len((AV*)svx) + 1;
	xvars = (DdNode **) safemalloc(len * sizeof(DdNode *));
	yvars = (DdNode **) safemalloc(len * sizeof(DdNode *));
	zvars = (DdNode **) safemalloc(len * sizeof(DdNode *));
	for (index = 0; index < len; index++) {
		xvars[index] = (DdNode *)
			SvIV(SvRV(*av_fetch((AV*)svx, index, FALSE)));
		yvars[index] = (DdNode *)
			SvIV(SvRV(*av_fetch((AV*)svy, index, FALSE)));
	}
	RETVAL = Cudd_Xgty(dd, len, zvars, xvars, yvars);
	safefree(xvars);
	safefree(yvars);
	safefree(zvars);
#line 3470 "Cudd.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_CProjection); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_CProjection)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "manager, R, Y");
    {
	DdManager*	manager;
	DdNode*	R;
	DdNode*	Y;
	DdNode *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "DdManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    manager = INT2PTR(DdManager *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::CProjection",
			"manager", "DdManagerPtr")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    R = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::CProjection",
			"R", "DdNodePtr")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "DdNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    Y = INT2PTR(DdNode *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Cudd::CProjection",
			"Y", "DdNodePtr")
;

	RETVAL = Cudd_CProjection(manager, R, Y);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "DdNodePtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cudd_SharingSize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cudd_SharingSize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ddref");
    {
#line 994 "Cudd.xs"
	I32 len;
	I32 index;
	SV  *rvx;
	SV  *svx;
	DdNode  **dds;
#line 3549 "Cudd.c"
	int	RETVAL;
	dXSTARG;
#line 1000 "Cudd.xs"
	rvx = ST(0);
	if (!SvROK(rvx))
		croak("Not a reference given to Size");
	svx = SvRV(rvx);
	if (SvTYPE(svx) != SVt_PVAV)
		croak("Not array reference given to Size");
	if (av_len((AV*)svx) < 0)
		croak("Empty array reference given to Size");
	len = av_len((AV*)svx) + 1;
	dds = (DdNode **) safemalloc(len * sizeof(DdNode *));
	for (index = 0; index < len; index++) {
		dds[index] = (DdNode *)
			SvIV(SvRV(*av_fetch((AV*)svx, index, FALSE)));
	}
	RETVAL = Cudd_SharingSize(dds, len);
	safefree(dds);
#line 3569 "Cudd.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Cudd); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Cudd)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("Cudd::constant", XS_Cudd_constant, file, "$$");
        (void)newXSproto_portable("Cudd::Init", XS_Cudd_Init, file, ";$$$$$");
        (void)newXSproto_portable("Cudd::Quit", XS_Cudd_Quit, file, "$");
        (void)newXSproto_portable("Cudd::Ref", XS_Cudd_Ref, file, "$");
        (void)newXSproto_portable("Cudd::RecursiveDeref", XS_Cudd_RecursiveDeref, file, "$$");
        (void)newXSproto_portable("Cudd::IterDerefBdd", XS_Cudd_IterDerefBdd, file, "$$");
        (void)newXSproto_portable("Cudd::DelayedDerefBdd", XS_Cudd_DelayedDerefBdd, file, "$$");
        (void)newXSproto_portable("Cudd::ReadOne", XS_Cudd_ReadOne, file, "$");
        (void)newXSproto_portable("Cudd::DagSize", XS_Cudd_DagSize, file, "$");
        (void)newXSproto_portable("Cudd::CountMinterm", XS_Cudd_CountMinterm, file, "$$$");
        (void)newXSproto_portable("Cudd::PrintDebug", XS_Cudd_PrintDebug, file, "$$$$");
        (void)newXSproto_portable("Cudd::PrintInfo", XS_Cudd_PrintInfo, file, "$");
        (void)newXSproto_portable("Cudd::ReadPeakLiveNodeCount", XS_Cudd_ReadPeakLiveNodeCount, file, "$");
        (void)newXSproto_portable("Cudd::ReadNodeCount", XS_Cudd_ReadNodeCount, file, "$");
        (void)newXSproto_portable("Cudd::bddNewVar", XS_Cudd_bddNewVar, file, "$");
        (void)newXSproto_portable("Cudd::bddNewVarAtLevel", XS_Cudd_bddNewVarAtLevel, file, "$$");
        (void)newXSproto_portable("Cudd::MakeTreeNode", XS_Cudd_MakeTreeNode, file, "$$$;$");
        (void)newXSproto_portable("Cudd::bddAnd", XS_Cudd_bddAnd, file, "$$$");
        (void)newXSproto_portable("Cudd::bddOr", XS_Cudd_bddOr, file, "$$$");
        (void)newXSproto_portable("Cudd::bddXor", XS_Cudd_bddXor, file, "$$$");
        (void)newXSproto_portable("Cudd::bddXnor", XS_Cudd_bddXnor, file, "$$$");
        (void)newXSproto_portable("Cudd::bddNand", XS_Cudd_bddNand, file, "$$$");
        (void)newXSproto_portable("Cudd::bddNor", XS_Cudd_bddNor, file, "$$$");
        (void)newXSproto_portable("Cudd::bddConstrain", XS_Cudd_bddConstrain, file, "$$$");
        (void)newXSproto_portable("Cudd::bddRestrict", XS_Cudd_bddRestrict, file, "$$$");
        (void)newXSproto_portable("Cudd::bddSqueeze", XS_Cudd_bddSqueeze, file, "$$$");
        (void)newXSproto_portable("Cudd::bddExistAbstract", XS_Cudd_bddExistAbstract, file, "$$$");
        (void)newXSproto_portable("Cudd::bddAndAbstract", XS_Cudd_bddAndAbstract, file, "$$$$");
        (void)newXSproto_portable("Cudd::bddUnivAbstract", XS_Cudd_bddUnivAbstract, file, "$$$");
        (void)newXSproto_portable("Cudd::bddCompose", XS_Cudd_bddCompose, file, "$$$$");
        (void)newXSproto_portable("Cudd::bddBooleanDiff", XS_Cudd_bddBooleanDiff, file, "$$$");
        (void)newXSproto_portable("Cudd::bddCorrelation", XS_Cudd_bddCorrelation, file, "$$$");
        (void)newXSproto_portable("Cudd::Decreasing", XS_Cudd_Decreasing, file, "$$$");
        (void)newXSproto_portable("Cudd::Increasing", XS_Cudd_Increasing, file, "$$$");
        (void)newXSproto_portable("Cudd::FindEssential", XS_Cudd_FindEssential, file, "$$");
        (void)newXSproto_portable("Cudd::Support", XS_Cudd_Support, file, "$$");
        (void)newXSproto_portable("Cudd::bddLiteralSetIntersection", XS_Cudd_bddLiteralSetIntersection, file, "$$$");
        (void)newXSproto_portable("Cudd::bddSwapVariables", XS_Cudd_bddSwapVariables, file, "$$$$");
        (void)newXSproto_portable("Cudd::SubsetHeavyBranch", XS_Cudd_SubsetHeavyBranch, file, "$$$$");
        (void)newXSproto_portable("Cudd::SupersetHeavyBranch", XS_Cudd_SupersetHeavyBranch, file, "$$$$");
        (void)newXSproto_portable("Cudd::SubsetShortPaths", XS_Cudd_SubsetShortPaths, file, "$$$$$");
        (void)newXSproto_portable("Cudd::SupersetShortPaths", XS_Cudd_SupersetShortPaths, file, "$$$$$");
        (void)newXSproto_portable("Cudd::Not", XS_Cudd_Not, file, "$");
        (void)newXSproto_portable("Cudd::ReadPerm", XS_Cudd_ReadPerm, file, "$$");
        (void)newXSproto_portable("Cudd::bddLeq", XS_Cudd_bddLeq, file, "$$$");
        (void)newXSproto_portable("Cudd::ShortestPath", XS_Cudd_ShortestPath, file, "$$$");
        (void)newXSproto_portable("Cudd::AutodynEnable", XS_Cudd_AutodynEnable, file, "$;$");
        (void)newXSproto_portable("Cudd::AutodynDisable", XS_Cudd_AutodynDisable, file, "$");
        (void)newXSproto_portable("Cudd::EnableReorderingReporting", XS_Cudd_EnableReorderingReporting, file, "$");
        (void)newXSproto_portable("Cudd::DisableReorderingReporting", XS_Cudd_DisableReorderingReporting, file, "$");
        (void)newXSproto_portable("Cudd::ReduceHeap", XS_Cudd_ReduceHeap, file, "$;$$");
        (void)newXSproto_portable("Cudd::ShuffleHeap", XS_Cudd_ShuffleHeap, file, "$$");
        (void)newXSproto_portable("Cudd::ReadSize", XS_Cudd_ReadSize, file, "$");
        (void)newXSproto_portable("Cudd::NodeReadIndex", XS_Cudd_NodeReadIndex, file, "$");
        (void)newXSproto_portable("Cudd::IsComplement", XS_Cudd_IsComplement, file, "$");
        (void)newXSproto_portable("Cudd::CheckZeroRef", XS_Cudd_CheckZeroRef, file, "$");
        (void)newXSproto_portable("Cudd::DumpDot", XS_Cudd_DumpDot, file, "$$$$");
        (void)newXSproto_portable("Cudd::SolveEqn", XS_Cudd_SolveEqn, file, "$$$$");
        (void)newXSproto_portable("Cudd::CofMinterm", XS_Cudd_CofMinterm, file, "$$");
        (void)newXSproto_portable("Cudd::ReorderingStatus", XS_Cudd_ReorderingStatus, file, "$");
        (void)newXSproto_portable("Cudd::bddIntersect", XS_Cudd_bddIntersect, file, "$$$");
        (void)newXSproto_portable("Cudd::bddConstrainDecomp", XS_Cudd_bddConstrainDecomp, file, "$$");
        (void)newXSproto_portable("Cudd::bddCharToVect", XS_Cudd_bddCharToVect, file, "$$");
        (void)newXSproto_portable("Cudd::PrioritySelect", XS_Cudd_PrioritySelect, file, "$$$$$$");
        (void)newXSproto_portable("Cudd::Dxygtdxz", XS_Cudd_Dxygtdxz, file, "$$$$");
        (void)newXSproto_portable("Cudd::Dxygtdyz", XS_Cudd_Dxygtdyz, file, "$$$$");
        (void)newXSproto_portable("Cudd::Xgty", XS_Cudd_Xgty, file, "$$$$");
        (void)newXSproto_portable("Cudd::CProjection", XS_Cudd_CProjection, file, "$$$");
        (void)newXSproto_portable("Cudd::SharingSize", XS_Cudd_SharingSize, file, "$");
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

